using ValueObject.SourceGenerator.Models;

namespace ValueObject.SourceGenerator.Emitters;

internal static class MongoDbClassMapEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
    {
        // Only consider VOs with supported underlying types (i.e., serializers are generated)
        var supported = vos.Where(v => MongoDbSerializerEmitter.IsSupportedUnderlying(v.TvDisplay)).ToArray();
        if (supported.Length == 0) return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using MongoDB.Bson.Serialization;");

        // Add using statements for all namespaces that contain VOs
        var namespaces = supported
            .Select(v => v.Namespace)
            .Where(ns => ns is not null)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(ns => ns, StringComparer.Ordinal);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace ValueObject.Core;");
        sb.AppendLine();
        sb.AppendLine("public static class MongoClassMaps");
        sb.AppendLine("{");
        sb.AppendLine("    public static void RegisterAll()");
        sb.AppendLine("    {");

        // Register all serializers, sorted by fully qualified name for consistency
        foreach (var vo in supported.OrderBy(v => $"{v.Namespace}.{v.TypeName}", StringComparer.Ordinal))
        {
            sb.AppendLine($"        BsonSerializer.RegisterSerializer(new {vo.TypeName}Serializer());");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        ctx.AddSource("MongoClassMaps.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
