# Entity Framework Core Integration

## Overview

The ValueObject generator automatically creates Entity Framework Core `ValueConverter` classes that seamlessly integrate your value objects with EF Core, enabling type-safe database mappings without additional configuration.

## Why EF Core Integration?

- **Automatic Conversion**: Transparent conversion between value objects and database types
- **Type Safety**: Strongly-typed properties in your entities
- **Zero Boilerplate**: Converters generated automatically
- **Nullable Support**: Handles both nullable and non-nullable value objects
- **Seamless Configuration**: Works with model builder extensions

## Generated Converters

For each value object, the generator creates two converter classes:

### Non-Nullable Converter

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

public class UserIdValueConverter : ValueConverter<UserId, Guid>
{
    public UserIdValueConverter() : base(
        v => (Guid)v,              // Convert UserId to Guid for database
        v => (UserId)v)            // Convert Guid from database to UserId
    { }
}
```

### Nullable Converter

```csharp
public class UserIdNullableValueConverter : ValueConverter<UserId?, Guid?>
{
    public UserIdNullableValueConverter() : base(
        v => v == null ? null : (Guid)v,           // Handle nullable
        v => v == null ? null : (UserId)v)         // Handle nullable
    { }
}
```

## Usage Examples

### Basic Configuration

```csharp
public class User
{
    public int Id { get; set; }
    public UserId UserId { get; set; }
    public string Name { get; set; }
}

public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>()
            .Property(u => u.UserId)
            .HasConversion(new UserIdValueConverter());
    }
}
```

### Using Generated Extensions

The generator also creates extension methods for convenience:

```csharp
public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        var userBuilder = modelBuilder.Entity<User>();
        
        // Use the generated extension method
        userBuilder.ConfigureValueObjectProperties();
    }
}
```

### Multiple Value Object Properties

```csharp
public class Order
{
    public int Id { get; set; }
    public OrderId OrderId { get; set; }        // Uses OrderIdValueConverter
    public UserId CustomerId { get; set; }      // Uses UserIdValueConverter
    public ProductId ProductId { get; set; }    // Uses ProductIdValueConverter
    public Quantity Quantity { get; set; }      // Uses QuantityValueConverter
    public Price TotalPrice { get; set; }       // Uses PriceValueConverter
}

public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Order>()
            .Property(o => o.OrderId)
            .HasConversion(new OrderIdValueConverter());
        
        modelBuilder.Entity<Order>()
            .Property(o => o.CustomerId)
            .HasConversion(new UserIdValueConverter());
        
        modelBuilder.Entity<Order>()
            .Property(o => o.ProductId)
            .HasConversion(new ProductIdValueConverter());
        
        modelBuilder.Entity<Order>()
            .Property(o => o.Quantity)
            .HasConversion(new QuantityValueConverter());
        
        modelBuilder.Entity<Order>()
            .Property(o => o.TotalPrice)
            .HasConversion(new PriceValueConverter());
    }
}
```

### Nullable Value Objects

```csharp
public class Product
{
    public int Id { get; set; }
    public ProductId ProductId { get; set; }
    
    // Optional discount
    public Discount? OptionalDiscount { get; set; }
    
    // Optional rating
    public Rating? OptionalRating { get; set; }
}

public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Product>()
            .Property(p => p.OptionalDiscount)
            .HasConversion(new DiscountNullableValueConverter());
        
        modelBuilder.Entity<Product>()
            .Property(p => p.OptionalRating)
            .HasConversion(new RatingNullableValueConverter());
    }
}
```

### Configurable Columns

```csharp
public class User
{
    public int Id { get; set; }
    public UserId UserId { get; set; }
    public Email Email { get; set; }
}

public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>()
            .Property(u => u.UserId)
            .HasConversion(new UserIdValueConverter())
            .HasColumnName("user_id")                    // Custom column name
            .HasColumnType("uniqueidentifier");          // Custom column type

        modelBuilder.Entity<User>()
            .Property(u => u.Email)
            .HasConversion(new EmailValueConverter())
            .HasMaxLength(255)                           // Max length constraint
            .IsRequired();                               // Required (not null)
    }
}
```

### Filtering and Queries

```csharp
public class UserRepository
{
    private readonly AppDbContext _context;

    public async Task<User> GetByIdAsync(UserId userId)
    {
        // EF Core automatically converts UserId to Guid
        return await _context.Users
            .FirstOrDefaultAsync(u => u.UserId == userId);
    }

    public async Task<List<User>> FindByMultipleIdsAsync(params UserId[] userIds)
    {
        // Works with collections too
        return await _context.Users
            .Where(u => userIds.Contains(u.UserId))
            .ToListAsync();
    }

    public async Task UpdateUserAsync(UserId userId, string newName)
    {
        var user = await GetByIdAsync(userId);
        if (user != null)
        {
            user.Name = newName;
            await _context.SaveChangesAsync();
        }
    }
}
```

### Inherited Properties

```csharp
public abstract class Entity
{
    public Guid Id { get; set; }
}

public class User : Entity
{
    public UserId UserId { get; set; }
    public Email Email { get; set; }
}

public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure base entity
        modelBuilder.Entity<Entity>()
            .HasKey(e => e.Id);

        // Configure derived entity with value objects
        modelBuilder.Entity<User>()
            .Property(u => u.UserId)
            .HasConversion(new UserIdValueConverter());

        modelBuilder.Entity<User>()
            .Property(u => u.Email)
            .HasConversion(new EmailValueConverter())
            .IsRequired();
    }
}
```

## Real-World Example: E-Commerce Domain

```csharp
// Domain entities
public class Product
{
    public int Id { get; set; }
    public ProductId ProductId { get; set; }
    public string Name { get; set; }
    public Price Price { get; set; }
    public Quantity StockQuantity { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public OrderId OrderId { get; set; }
    public UserId CustomerId { get; set; }
    public DateTime CreatedAt { get; set; }
    public List<OrderItem> Items { get; set; }
    public Price TotalAmount { get; set; }
}

public class OrderItem
{
    public int Id { get; set; }
    public ProductId ProductId { get; set; }
    public Quantity Quantity { get; set; }
    public Price UnitPrice { get; set; }
    public Order Order { get; set; }
}

// Database context
public class ECommerceDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }
    public DbSet<Order> Orders { get; set; }
    public DbSet<OrderItem> OrderItems { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Products
        modelBuilder.Entity<Product>()
            .HasKey(p => p.Id);
        
        modelBuilder.Entity<Product>()
            .Property(p => p.ProductId)
            .HasConversion(new ProductIdValueConverter())
            .IsRequired();
        
        modelBuilder.Entity<Product>()
            .Property(p => p.Price)
            .HasConversion(new PriceValueConverter());
        
        modelBuilder.Entity<Product>()
            .Property(p => p.StockQuantity)
            .HasConversion(new QuantityValueConverter());

        // Orders
        modelBuilder.Entity<Order>()
            .HasKey(o => o.Id);
        
        modelBuilder.Entity<Order>()
            .Property(o => o.OrderId)
            .HasConversion(new OrderIdValueConverter())
            .IsRequired();
        
        modelBuilder.Entity<Order>()
            .Property(o => o.CustomerId)
            .HasConversion(new UserIdValueConverter())
            .IsRequired();
        
        modelBuilder.Entity<Order>()
            .Property(o => o.TotalAmount)
            .HasConversion(new PriceValueConverter());

        // Order Items
        modelBuilder.Entity<OrderItem>()
            .HasKey(oi => oi.Id);
        
        modelBuilder.Entity<OrderItem>()
            .Property(oi => oi.ProductId)
            .HasConversion(new ProductIdValueConverter());
        
        modelBuilder.Entity<OrderItem>()
            .Property(oi => oi.Quantity)
            .HasConversion(new QuantityValueConverter());
        
        modelBuilder.Entity<OrderItem>()
            .Property(oi => oi.UnitPrice)
            .HasConversion(new PriceValueConverter());

        // Relationships
        modelBuilder.Entity<Order>()
            .HasMany(o => o.Items)
            .WithOne(oi => oi.Order);
    }
}

// Usage
public class OrderService
{
    private readonly ECommerceDbContext _context;

    public async Task<Order> GetOrderByIdAsync(OrderId orderId)
    {
        return await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.OrderId == orderId);
    }

    public async Task<List<Order>> GetOrdersByCustomerAsync(UserId customerId)
    {
        return await _context.Orders
            .Where(o => o.CustomerId == customerId)
            .OrderByDescending(o => o.CreatedAt)
            .ToListAsync();
    }

    public async Task<decimal> GetTotalSalesAsync(Price minimumOrderValue)
    {
        return await _context.Orders
            .Where(o => o.TotalAmount >= minimumOrderValue)
            .Select(o => o.TotalAmount)
            .SumAsync(p => (decimal)p);
    }
}
```

## Generated Extension Method

For entities with value object properties, an extension method is generated:

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

public static class ValueObjectEfCoreExtensions
{
    public static void ConfigureValueObjectProperties(this EntityTypeBuilder<Order> entity)
    {
        entity.Property(e => e.OrderId).HasConversion(new OrderIdValueConverter());
        entity.Property(e => e.CustomerId).HasConversion(new UserIdValueConverter());
        entity.Property(e => e.ProductId).HasConversion(new ProductIdValueConverter());
        entity.Property(e => e.Quantity).HasConversion(new QuantityValueConverter());
        entity.Property(e => e.TotalPrice).HasConversion(new PriceValueConverter());
    }
}
```

Use it in `OnModelCreating`:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Order>()
        .ConfigureValueObjectProperties();
}
```

## Performance Notes

- **Zero overhead**: Converters compile to direct type casts in LINQ
- **Database queries**: Comparisons in LINQ are translated to database SQL
- **No reflection**: No runtime type detection or boxing
- **Efficient**: Works with indexes on value object properties

## Disabling EF Core Generation

If you don't use EF Core, you can disable generation in your assembly:

```csharp
[assembly: ValueObjectSettings(
    generateMongoDbSerializer: true,
    generateEfCoreValueConverter: false  // Disable EF Core converters
)]
```

See [Configuration](./CONFIGURATION.md) for more details.

## Next Steps

- **[Getting Started](./GETTING_STARTED.md)** - Basic usage guide
- **[MongoDB Integration](./MONGODB.md)** - MongoDB serialization
- **[Configuration](./CONFIGURATION.md)** - Customize generator behavior
- **[Operators Emitter](./OPERATORS_EMITTER.md)** - Operators and conversions

