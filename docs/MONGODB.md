# MongoDB Integration

## Overview

The ValueObject generator automatically creates MongoDB BSON serializers for value objects, enabling seamless serialization and deserialization when working with MongoDB and the C# MongoDB driver.

## Why MongoDB Integration?

- **Automatic Serializers**: BSON serializers generated automatically for supported types
- **Transparent Conversion**: Value objects serialize/deserialize transparently
- **Type Safety**: Strongly-typed MongoDB documents
- **Zero Boilerplate**: No manual serializer code needed
- **Easy Registration**: One-line registration of all serializers

## Supported Types for MongoDB

The generator creates serializers for value objects with these underlying types:

- `string`
- `int`, `long`
- `double`, `decimal`
- `bool`
- `Guid`
- `byte[]` (binary data)
- `DateTime`
- `MongoDB.Bson.ObjectId`

## Generated Serializers

For each compatible value object, the generator creates a BSON serializer:

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

using MongoDB.Bson;
using MongoDB.Bson.Serialization;
using MongoDB.Bson.Serialization.Serializers;

public class UserIdSerializer : StructSerializerBase<UserId>
{
    public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, UserId value)
    {
        var guidSerializer = new GuidSerializer(BsonType.String);
        guidSerializer.Serialize(context, args, value.Value);
    }

    public override UserId Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)
    {
        var guidSerializer = new GuidSerializer(BsonType.String);
        var guidValue = guidSerializer.Deserialize(context, args);
        return new UserId(guidValue);
    }
}
```

## Class Map Registration

The generator also creates a registration helper:

```csharp
// <auto-generated />
#nullable enable
using MongoDB.Bson.Serialization;
using YourNamespace;

namespace ValueObject.Core;

public static class MongoClassMaps
{
    public static void RegisterAll()
    {
        BsonSerializer.RegisterSerializer(new UserIdSerializer());
        BsonSerializer.RegisterSerializer(new OrderIdSerializer());
        BsonSerializer.RegisterSerializer(new ProductIdSerializer());
        BsonSerializer.RegisterSerializer(new PriceSerializer());
        // ... one for each supported value object
    }
}
```

## Usage Examples

### Basic Setup

```csharp
// In Program.cs or initialization code
using ValueObject.Core;

// Register all value object serializers
MongoClassMaps.RegisterAll();

// Now use MongoDB normally
var client = new MongoClient("mongodb://localhost:27017");
var database = client.GetDatabase("myapp");
var collection = database.GetCollection<Product>("products");
```

### Document with Value Objects

```csharp
public partial record ProductId(Guid Value) : IValueObject<Guid>;
public partial record ProductName(string Value) : IValueObject<string>;
public partial record Price(decimal Value) : IValueObject<decimal>;
public partial record StockQuantity(int Value) : IValueObject<int>;

public class Product
{
    [BsonId]
    public ObjectId Id { get; set; }

    public ProductId ProductId { get; set; }
    public ProductName Name { get; set; }
    public Price Price { get; set; }
    public StockQuantity Stock { get; set; }
    public DateTime CreatedAt { get; set; }
}

// Automatic serialization - no configuration needed!
var product = new Product
{
    ProductId = new ProductId(Guid.NewGuid()),
    Name = new ProductName("Widget"),
    Price = new Price(19.99m),
    Stock = new StockQuantity(100),
    CreatedAt = DateTime.UtcNow
};

await collection.InsertOneAsync(product);
```

### Querying Documents

```csharp
public class ProductRepository
{
    private readonly IMongoCollection<Product> _collection;

    public async Task<Product> GetByIdAsync(ProductId productId)
    {
        // Works naturally with value objects in filters
        var filter = Builders<Product>.Filter.Eq(p => p.ProductId, productId);
        return await _collection.Find(filter).FirstOrDefaultAsync();
    }

    public async Task<List<Product>> FindByNameAsync(ProductName name)
    {
        var filter = Builders<Product>.Filter.Eq(p => p.Name, name);
        return await _collection.Find(filter).ToListAsync();
    }

    public async Task<List<Product>> FindExpensiveProductsAsync(Price minimumPrice)
    {
        var filter = Builders<Product>.Filter.Gte(p => p.Price, minimumPrice);
        return await _collection.Find(filter)
            .SortByDescending(p => p.Price)
            .ToListAsync();
    }

    public async Task UpdateStockAsync(ProductId productId, StockQuantity newStock)
    {
        var filter = Builders<Product>.Filter.Eq(p => p.ProductId, productId);
        var update = Builders<Product>.Update.Set(p => p.Stock, newStock);
        await _collection.UpdateOneAsync(filter, update);
    }
}
```

### Complex Queries

```csharp
var minPrice = new Price(50m);
var maxPrice = new Price(200m);

var filter = Builders<Product>.Filter.And(
    Builders<Product>.Filter.Gte(p => p.Price, minPrice),
    Builders<Product>.Filter.Lte(p => p.Price, maxPrice),
    Builders<Product>.Filter.Gt(p => p.Stock, new StockQuantity(0))
);

var results = await collection.Find(filter)
    .SortByDescending(p => p.Price)
    .ToListAsync();
```

## Real-World Example: Order Management

```csharp
// Domain value objects
public partial record OrderId(ObjectId Value) : IValueObject<ObjectId>;
public partial record CustomerId(ObjectId Value) : IValueObject<ObjectId>;
public partial record ProductId(ObjectId Value) : IValueObject<ObjectId>;
public partial record Price(decimal Value) : IValueObject<decimal>;
public partial record Quantity(int Value) : IValueObject<int>;
public partial record CustomerEmail(string Value) : IValueObject<string>;

// MongoDB document
public class Order
{
    [BsonId]
    public OrderId Id { get; set; }

    public CustomerId CustomerId { get; set; }
    public List<OrderLineItem> Items { get; set; }
    public Price TotalPrice { get; set; }
    public OrderStatus Status { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class OrderLineItem
{
    public ProductId ProductId { get; set; }
    public Quantity Quantity { get; set; }
    public Price UnitPrice { get; set; }
}

public class Customer
{
    [BsonId]
    public CustomerId Id { get; set; }

    public CustomerEmail Email { get; set; }
    public string Name { get; set; }
    public DateTime RegisteredAt { get; set; }
}

// Repository
public class OrderRepository
{
    private readonly IMongoCollection<Order> _orderCollection;
    private readonly IMongoCollection<Customer> _customerCollection;

    public async Task CreateOrderAsync(CustomerId customerId, List<(ProductId, Quantity, Price)> items)
    {
        var totalPrice = new Price(items.Sum(i => (decimal)i.Item3 * i.Item2.Value));

        var order = new Order
        {
            Id = new OrderId(ObjectId.GenerateNewId()),
            CustomerId = customerId,
            Items = items.Select(i => new OrderLineItem
            {
                ProductId = i.Item1,
                Quantity = i.Item2,
                UnitPrice = i.Item3
            }).ToList(),
            TotalPrice = totalPrice,
            Status = OrderStatus.Pending,
            CreatedAt = DateTime.UtcNow
        };

        await _orderCollection.InsertOneAsync(order);
    }

    public async Task<List<Order>> GetCustomerOrdersAsync(CustomerId customerId)
    {
        var filter = Builders<Order>.Filter.Eq(o => o.CustomerId, customerId);
        return await _orderCollection.Find(filter)
            .SortByDescending(o => o.CreatedAt)
            .ToListAsync();
    }

    public async Task<List<Order>> FindHighValueOrdersAsync(Price minimumTotal)
    {
        var filter = Builders<Order>.Filter.Gte(o => o.TotalPrice, minimumTotal);
        return await _orderCollection.Find(filter)
            .SortByDescending(o => o.TotalPrice)
            .ToListAsync();
    }

    public async Task UpdateOrderStatusAsync(OrderId orderId, OrderStatus newStatus)
    {
        var filter = Builders<Order>.Filter.Eq(o => o.Id, orderId);
        var update = Builders<Order>.Update.Set(o => o.Status, newStatus);
        await _orderCollection.UpdateOneAsync(filter, update);
    }
}

// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Register all value object serializers before using MongoDB
MongoClassMaps.RegisterAll();

var app = builder.Build();

// Use repositories with value objects
app.MapPost("/orders", async (OrderService service, CreateOrderRequest request) =>
{
    var customerId = new CustomerId(ObjectId.Parse(request.CustomerId));
    await service.CreateOrderAsync(customerId, request.Items);
    return Results.Ok();
});
```

## Object Serialization Behavior

### String-Based Value Objects

```csharp
public partial record Email(string Value) : IValueObject<string>;

// Serialized as BSON string
{ "email" : "john@example.com" }
```

### GUID-Based Value Objects

```csharp
public partial record UserId(Guid Value) : IValueObject<Guid>;

// Serialized as BSON UUID/GUID
{ "userId" : UUID("550e8400-e29b-41d4-a716-446655440000") }
```

### ObjectId-Based Value Objects

```csharp
public partial record ProductId(ObjectId Value) : IValueObject<ObjectId>;

// Serialized as BSON ObjectId
{ "productId" : ObjectId("507f1f77bcf86cd799439011") }
```

### Numeric Value Objects

```csharp
public partial record Price(decimal Value) : IValueObject<decimal>;
public partial record Quantity(int Value) : IValueObject<int>;

// Serialized as BSON number types
{ "price" : 19.99, "quantity" : 10 }
```

## Initialization

### Option 1: Application Startup

```csharp
// Program.cs
using ValueObject.Core;

var builder = WebApplication.CreateBuilder(args);

// Register serializers before creating any MongoDB clients
MongoClassMaps.RegisterAll();

var app = builder.Build();
app.Run();
```

### Option 2: Service Configuration

```csharp
// MongoDbConfiguration.cs
public static class MongoDbConfiguration
{
    public static IServiceCollection AddMongoDb(this IServiceCollection services, string connectionString)
    {
        MongoClassMaps.RegisterAll();

        var client = new MongoClient(connectionString);
        services.AddSingleton(client);

        var database = client.GetDatabase("myapp");
        services.AddSingleton(database);

        return services;
    }
}

// Program.cs
builder.Services.AddMongoDb("mongodb://localhost:27017");
```

### Option 3: Lazy Initialization

```csharp
public class MongoDbContext
{
    private static readonly Lazy<bool> _initialized = new(() =>
    {
        MongoClassMaps.RegisterAll();
        return true;
    });

    public static void EnsureInitialized() => _ = _initialized.Value;
}

// Usage
MongoDbContext.EnsureInitialized();
var client = new MongoClient("mongodb://localhost:27017");
```

## BSON Document Structure

Here's how documents look in MongoDB with value objects:

```json
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "orderId": ObjectId("507f1f77bcf86cd799439012"),
  "customerId": ObjectId("507f1f77bcf86cd799439013"),
  "items": [
    {
      "productId": ObjectId("507f1f77bcf86cd799439014"),
      "quantity": 5,
      "unitPrice": 19.99
    }
  ],
  "totalPrice": 99.95,
  "status": "Pending",
  "createdAt": ISODate("2024-01-15T10:30:00Z")
}
```

## Performance Considerations

- **Serializers cached**: MongoDB driver caches serializers, no reflection at runtime
- **Direct serialization**: Value objects serialize to their underlying types
- **Efficient queries**: Filter expressions compile to efficient BSON queries
- **No boxing**: Value types work efficiently without boxing overhead

## Disabling MongoDB Generation

If you don't use MongoDB, disable generation in your assembly:

```csharp
[assembly: ValueObjectSettings(
    generateMongoDbSerializer: false,  // Disable MongoDB serializers
    generateEfCoreValueConverter: true
)]
```

See [Configuration](./CONFIGURATION.md) for more details.

## Next Steps

- **[Getting Started](./GETTING_STARTED.md)** - Basic usage guide
- **[Entity Framework Core](./ENTITY_FRAMEWORK.md)** - EF Core integration
- **[Configuration](./CONFIGURATION.md)** - Customize generator behavior
- **[TryParse Emitter](./TRYPARSE_EMITTER.md)** - Safe parsing methods

