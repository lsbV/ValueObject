# Type Extensions (The As Pattern)

## Overview

The Type Extensions emitter generates helper classes that enable convenient type casting and access to multiple value objects sharing the same underlying type, using the ergonomic `As` pattern.

## Why Type Extensions?

Type extensions provide:
- **Grouped access**: Access all value objects of the same underlying type from a single entry point
- **Ergonomic syntax**: Natural `.As()` method on any value of your type
- **Type safety**: Compile-time checked conversions
- **Discoverability**: IDE intellisense helps you find all value objects for a type

## Generated Code Example

If you define multiple value objects wrapping the same `string` type:

```csharp
public partial record Email(string Value) : IValueObject<string>;
public partial record UserName(string Value) : IValueObject<string>;
public partial record Url(string Value) : IValueObject<string>;
```

The generator creates a `StringAs` helper class and extension method:

```csharp
// <auto-generated />
using YourNamespace;

namespace ValueObject.Core;

public readonly record struct StringAs : IAs<string>
{
    public string Value { get; }
    public StringAs(string value) : this() => Value = value;

    // One property per value object with the same underlying type
    public Email Email => (Email)Value;
    public UserName UserName => (UserName)Value;
    public Url Url => (Url)Value;
}

// Extension method on string
public static class AsExtensions
{
    extension(string value)
    {
        public StringAs As => new StringAs(value);
    }
}
```

## Usage Examples

### Converting Between Value Objects of the Same Type

```csharp
public partial record Email(string Value) : IValueObject<string>;
public partial record UserName(string Value) : IValueObject<string>;

var userNameStr = "john_doe";

// Convert string to Email using As pattern
var email = userNameStr.As().Email; // userNameStr cast as Email

var emailValue = new Email("john@example.com");

// Convert Email to UserName
var userName = emailValue.As().UserName; // Email's underlying value cast as UserName
```

### Accessing Multiple Value Objects

```csharp
public partial record FirstName(string Value) : IValueObject<string>;
public partial record LastName(string Value) : IValueObject<string>;
public partial record MiddleName(string Value) : IValueObject<string>;
public partial record NickName(string Value) : IValueObject<string>;

var rawName = "John";

// Single As() gives access to all string-based name value objects
var nameVariants = rawName.As();

var firstName = nameVariants.FirstName;
var lastName = nameVariants.LastName;
var middleName = nameVariants.MiddleName;
var nickName = nameVariants.NickName;
```

### With GUIDs

```csharp
public partial record UserId(Guid Value) : IValueObject<Guid>;
public partial record ProductId(Guid Value) : IValueObject<Guid>;
public partial record OrderId(Guid Value) : IValueObject<Guid>;

var guidValue = Guid.NewGuid();

// Convert between Guid-based value objects
var userId = guidValue.As().UserId;
var productId = guidValue.As().ProductId;
var orderId = guidValue.As().OrderId;
```

### In Data Processing Pipelines

```csharp
public partial record Source(string Value) : IValueObject<string>;
public partial record Destination(string Value) : IValueObject<string>;
public partial record Label(string Value) : IValueObject<string>;

public class DataTransformer
{
    public void TransformData(string sourceStr)
    {
        // Convert raw string to specific value object
        var source = sourceStr.As().Source;

        // Process...
        var result = Process(source);

        // Convert result string to different value object
        var destination = result.As().Destination;

        // Further processing...
        var labeled = Label(destination);
    }
}
```

### With Numeric Types

```csharp
public partial record Age(int Value) : IValueObject<int>;
public partial record Quantity(int Value) : IValueObject<int>;
public partial record Priority(int Value) : IValueObject<int>;

var intValue = 42;

// Access all int-based value objects
var as = intValue.As();

var age = as.Age;
var quantity = as.Quantity;
var priority = as.Priority;
```

## Generated Classes

### StringAs Example

```csharp
public readonly record struct StringAs : IAs<string>
{
    public string Value { get; }
    public StringAs(string value) : this() => Value = value;

    // Add a property for each string-based value object
    public Email Email => (Email)Value;
    public UserName UserName => (UserName)Value;
    public Url Url => (Url)Value;
}
```

### GuidAs Example

```csharp
public readonly record struct GuidAs : IAs<Guid>
{
    public Guid Value { get; }
    public GuidAs(Guid value) : this() => Value = value;

    // Add a property for each Guid-based value object
    public UserId UserId => (UserId)Value;
    public ProductId ProductId => (ProductId)Value;
    public OrderId OrderId => (OrderId)Value;
}
```

### IntAs Example

```csharp
public readonly record struct IntAs : IAs<int>
{
    public int Value { get; }
    public IntAs(int value) : this() => Value = value;

    // Add a property for each int-based value object
    public Age Age => (Age)Value;
    public Quantity Quantity => (Quantity)Value;
    public Priority Priority => (Priority)Value;
}
```

## Extension Methods

One extension method is created for each underlying type:

```csharp
namespace ValueObject.Core;

public static class AsExtensions
{
    // For strings
    extension(string value)
    {
        public StringAs As => new StringAs(value);
    }

    // For Guids
    extension(Guid value)
    {
        public GuidAs As => new GuidAs(value);
    }

    // For ints
    extension(int value)
    {
        public IntAs As => new IntAs(value);
    }

    // ... one for each underlying type used by your value objects
}
```

## Type Mapping Reference

The generator automatically creates one `XyzAs` class and extension for each underlying type found:

| Underlying Type | Generated Class | Extension Location |
|---|---|---|
| `string` | `StringAs` | `string.As()` |
| `Guid` | `GuidAs` | `Guid.As()` |
| `int` | `IntAs` | `int.As()` |
| `long` | `LongAs` | `long.As()` |
| `decimal` | `DecimalAs` | `decimal.As()` |
| `double` | `DoubleAs` | `double.As()` |
| `bool` | `BoolAs` | `bool.As()` |
| `DateTime` | `DateTimeAs` | `DateTime.As()` |
| `MongoDB.Bson.ObjectId` | `ObjectIdAs` | `ObjectId.As()` |

## Real-World Example: Address Domain

```csharp
// Multiple string-based address components
public partial record Street(string Value) : IValueObject<string>;
public partial record City(string Value) : IValueObject<string>;
public partial record PostalCode(string Value) : IValueObject<string>;
public partial record Country(string Value) : IValueObject<string>;

// Parse and convert address data
public class AddressParser
{
    public Address ParseFromCsv(string csvLine)
    {
        var parts = csvLine.Split(',');

        // Convenient conversion using As pattern
        return new Address
        {
            Street = parts[0].As().Street,
            City = parts[1].As().City,
            PostalCode = parts[2].As().PostalCode,
            Country = parts[3].As().Country,
        };
    }
}
```

## Real-World Example: Identifiers

```csharp
public partial record UserId(Guid Value) : IValueObject<Guid>;
public partial record ProductId(Guid Value) : IValueObject<Guid>;
public partial record OrderId(Guid Value) : IValueObject<Guid>;

public class EventPublisher
{
    public void PublishEvent(Guid eventId, Guid relatedId, EventType type)
    {
        var relatedAs = relatedId.As();

        var @event = type switch
        {
            EventType.UserCreated => new UserCreatedEvent(relatedAs.UserId, eventId),
            EventType.ProductAdded => new ProductAddedEvent(relatedAs.ProductId, eventId),
            EventType.OrderPlaced => new OrderPlacedEvent(relatedAs.OrderId, eventId),
            _ => throw new ArgumentException("Unknown event type")
        };

        Publish(@event);
    }
}
```

## Benefits

### Reduces Boilerplate

```csharp
// ❌ Without As pattern - verbose
var stringValue = "test";
var email = new Email(stringValue);
var userName = new UserName(stringValue);

// ✅ With As pattern - concise
var as = stringValue.As();
var email = as.Email;
var userName = as.UserName;
```

### Improves Discoverability

The IDE's intellisense shows all available value objects for a type when you type `.As()`:

```csharp
var str = "example";
var options = str.As(). // Intellisense shows: Email, UserName, Url, etc.
```

### Safer Conversions

Explicit conversion syntax prevents mixing up types:

```csharp
// Clear intent - converting to specific type
var userId = guidValue.As().UserId;

// vs less clear
var userId = (UserId)guidValue;
```

## Performance

- **Stack allocated**: `XyzAs` records are struct types, allocated on the stack
- **Zero overhead**: Conversion properties are inlined to simple casts
- **No boxing**: Works efficiently with value types
- **Temporary**: The `As` object doesn't need to be stored

## Next Steps

- **[Getting Started](./GETTING_STARTED.md)** - Basic usage guide
- **[Operators Emitter](./OPERATORS_EMITTER.md)** - Type conversions and operators
- **[TryParse Emitter](./TRYPARSE_EMITTER.md)** - Safe parsing methods
- **[Configuration](./CONFIGURATION.md)** - Customize generator behavior

