using ValueObject.SourceGenerator.Models;

namespace ValueObject.SourceGenerator.Emitters;

internal static class EfCoreModelBuilderEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<EntityValueObjectProperty> entityProps)
    {
        if(!entityProps.Any()) return;

        var grouped = entityProps.GroupBy(x => (x.EntityNamespace, x.EntityName));
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore.Metadata.Builders;");
        sb.AppendLine();
        // Put extensions in the same namespace as the entities
        foreach (var group in grouped)
        {
            var (ns, entityName) = group.Key;
            if (ns != null)
            {
                sb.AppendLine($"namespace {ns};");
                sb.AppendLine();
            }
            sb.AppendLine("public static class ValueObjectEfCoreExtensions");
            sb.AppendLine("{");
            sb.AppendLine($"    public static void ConfigureValueObjectProperties(this EntityTypeBuilder<{entityName}> entity)");
            sb.AppendLine("    {");
            foreach (var prop in group)
            {
                var converterType = prop.IsNullable ? $"{prop.ValueObjectTypeName}NullableValueConverter" : $"{prop.ValueObjectTypeName}ValueConverter";
                sb.AppendLine($"        entity.Property(e => e.{prop.PropertyName}).HasConversion(new {converterType}());");
            }
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }
        ctx.AddSource("ValueObjectEfCoreExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
