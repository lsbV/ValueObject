using ValueObject.SourceGenerator.Models;

namespace ValueObject.SourceGenerator.Emitters;

internal static class MongoDbSerializerEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
    {
        foreach (var vo in vos)
        {
            if (!IsSupportedUnderlying(vo.TvDisplay))
                continue; // only emit for supported underlying types

            var sb = new StringBuilder();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();
            sb.AppendLine("using MongoDB.Bson;");
            sb.AppendLine("using MongoDB.Bson.Serialization;");
            sb.AppendLine("using MongoDB.Bson.Serialization.Serializers;");
            sb.AppendLine();

            // Keep the same namespace as the source type
            if (vo.Namespace is not null)
            {
                sb.AppendLine($"namespace {vo.Namespace};");
                sb.AppendLine();
            }
            var type = vo.IsRecordStruct ? "Struct" : "Class";

            // Generate the serializer class
            sb.AppendLine($"public class {vo.TypeName}Serializer : {type}SerializerBase<{vo.TypeName}>");
            sb.AppendLine("{");
            sb.AppendLine($"    public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, {vo.TypeName} value)");
            sb.AppendLine("    {");
            EmitSerializationCode(sb, vo);
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine($"    public override {vo.TypeName} Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)");
            sb.AppendLine("    {");
            EmitDeserializationCode(sb, vo);
            sb.AppendLine("    }");
            sb.AppendLine("}");

            ctx.AddSource($"{vo.TypeName}_MongoDbSerializer.g.cs",
             SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    public static bool IsSupportedUnderlying(string tv)
    => tv switch
    {
        "global::MongoDB.Bson.ObjectId" => true,
        "global::System.String" => true,
        "global::System.Int32" => true,
        "global::System.Int64" => true,
        "global::System.Double" => true,
        "global::System.Decimal" => true,
        "global::System.Boolean" => true,
        "global::System.Guid" => true,
        "global::System.Byte[]" => true,
        "global::System.DateTime" => true,

        "string" => true,
        "int" => true,
        "long" => true,
        "double" => true,
        "decimal" => true,
        "bool" => true,
        "System.Guid" => true,
        "byte[]" => true,
        "System.DateTime" => true,
        _ => false
    };

    private static void EmitSerializationCode(StringBuilder sb, VoCandidate vo)
    {
        switch (vo.TvDisplay)
        {
            case "global::MongoDB.Bson.ObjectId":
                sb.AppendLine("        context.Writer.WriteObjectId(value.Value);");
                break;
            case "global::System.String" or "string":
                sb.AppendLine("        context.Writer.WriteString(value.Value);");
                break;
            case "global::System.Int32" or "int":
                sb.AppendLine("        context.Writer.WriteInt32(value.Value);");
                break;
            case "global::System.Int64" or "long":
                sb.AppendLine("        context.Writer.WriteInt64(value.Value);");
                break;
            case "global::System.Double" or "double":
                sb.AppendLine("        context.Writer.WriteDouble(value.Value);");
                break;
            case "global::System.Decimal" or "decimal":
                sb.AppendLine("        context.Writer.WriteDecimal128(new Decimal128(value.Value));");
                break;
            case "global::System.Boolean" or "bool":
                sb.AppendLine("        context.Writer.WriteBoolean(value.Value);");
                break;
            case "global::System.Guid" or "Guid":
                sb.AppendLine("        context.Writer.WriteString(value.Value.ToString());");
                break;
            case "global::System.Byte[]" or "byte[]":
                sb.AppendLine("        context.Writer.WriteBytes(value.Value);");
                break;
            case "global::System.DateTime" or "DateTime":
                sb.AppendLine("        var ms = BsonUtils.ToMillisecondsSinceEpoch(value.Value.ToUniversalTime());");
                sb.AppendLine("        context.Writer.WriteDateTime(ms);");
                break;
            default:
                sb.AppendLine("        // Unsupported underlying type for MongoDB serializer");
                sb.AppendLine("        throw new NotSupportedException(\"Unsupported underlying type for MongoDB serializer\");");
                break;
        }
    }

    private static void EmitDeserializationCode(StringBuilder sb, VoCandidate vo)
    {
        switch (vo.TvDisplay)
        {
            case "global::MongoDB.Bson.ObjectId":
                sb.AppendLine("        var oid = context.Reader.ReadObjectId();");
                sb.AppendLine($"        return new {vo.TypeName}(oid);");
                break;
            case "global::System.String" or "string":
                sb.AppendLine("        var s = context.Reader.ReadString();");
                sb.AppendLine($"        return new {vo.TypeName}(s);");
                break;
            case "global::System.Int32" or "int":
                sb.AppendLine("        var i = context.Reader.ReadInt32();");
                sb.AppendLine($"        return new {vo.TypeName}(i);");
                break;
            case "global::System.Int64" or "long":
                sb.AppendLine("        var l = context.Reader.ReadInt64();");
                sb.AppendLine($"        return new {vo.TypeName}(l);");
                break;
            case "global::System.Double" or "double":
                sb.AppendLine("        var d = context.Reader.ReadDouble();");
                sb.AppendLine($"        return new {vo.TypeName}(d);");
                break;
            case "global::System.Decimal" or "decimal":
                sb.AppendLine("        var d128 = context.Reader.ReadDecimal128();");
                sb.AppendLine("        var dec = d128.ToDecimal();");
                sb.AppendLine($"        return new {vo.TypeName}(dec);");
                break;
            case "global::System.Boolean" or "bool":
                sb.AppendLine("        var b = context.Reader.ReadBoolean();");
                sb.AppendLine($"        return new {vo.TypeName}(b);");
                break;
            case "global::System.Guid" or "Guid":
                sb.AppendLine("        var gs = context.Reader.ReadString();");
                sb.AppendLine("        var g = global::System.Guid.Parse(gs);");
                sb.AppendLine($"        return new {vo.TypeName}(g);");
                break;
            case "global::System.Byte[]" or "byte[]":
                sb.AppendLine("        var bytes = context.Reader.ReadBytes();");
                sb.AppendLine($"        return new {vo.TypeName}(bytes);");
                break;
            case "global::System.DateTime" or "DateTime":
                sb.AppendLine("        var ms = context.Reader.ReadDateTime();");
                sb.AppendLine("        var dt = BsonUtils.ToDateTimeFromMillisecondsSinceEpoch(ms);");
                sb.AppendLine($"        return new {vo.TypeName}(dt);");
                break;
            default:
                sb.AppendLine("        // Unsupported underlying type for MongoDB serializer");
                sb.AppendLine("        throw new NotSupportedException(\"Unsupported underlying type for MongoDB serializer\");");
                break;
        }
    }
}
