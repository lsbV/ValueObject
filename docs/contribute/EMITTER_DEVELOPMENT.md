# Emitter Development Guide

This guide explains how to create new emitters for the ValueObject source generator.

## What is an Emitter?

An emitter is a class responsible for generating one aspect of value object code. The generator calls each emitter with discovered value objects, and the emitter generates the corresponding C# code.

## Basic Emitter Structure

All emitters follow this pattern:

```csharp
namespace ValueObject.SourceGenerator.Emitters;

internal static class MyNewEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
    {
        foreach (var vo in vos)
        {
            var sb = new StringBuilder();
            
            // Build the generated code
            sb.AppendLine("// Generated code here");
            
            // Add source to context
            ctx.AddSource($"{vo.TypeName}_MyFeature.g.cs", 
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}
```

## Step-by-Step: Creating a New Emitter

### Step 1: Create the Emitter Class

```csharp
// File: src/ValueObject.SourceGenerator/Emitters/MyFeatureEmitter.cs

namespace ValueObject.SourceGenerator.Emitters;

internal static class MyFeatureEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
    {
        // Implementation
    }
}
```

**Key points:**
- Class name should end with `Emitter`
- Should be `internal static`
- `Emit` method is the entry point
- Takes `SourceProductionContext` and collection of `VoCandidate`

### Step 2: Iterate Through Value Objects

```csharp
public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
{
    foreach (var vo in vos)
    {
        // Process each value object
        var code = GenerateCodeFor(vo);
        ctx.AddSource($"{vo.TypeName}_MyFeature.g.cs", code);
    }
}
```

### Step 3: Generate Code Using StringBuilder

```csharp
private static SourceText GenerateCodeFor(VoCandidate vo)
{
    var sb = new StringBuilder();
    
    // Header
    sb.AppendLine("// <auto-generated />");
    sb.AppendLine($"#nullable enable");
    
    // Namespace
    if (vo.Namespace is not null)
    {
        sb.AppendLine($"namespace {vo.Namespace};");
        sb.AppendLine();
    }
    
    // Class declaration (match original structure)
    var ro = vo.IsReadOnly ? "readonly " : string.Empty;
    var rs = vo.IsRecordStruct ? "record struct" : "record";
    sb.AppendLine($"public {ro} partial {rs} {vo.TypeName}");
    sb.AppendLine("{");
    
    // Generate methods...
    sb.AppendLine("    public void MyMethod() { }");
    
    sb.AppendLine("}");
    
    return SourceText.From(sb.ToString(), Encoding.UTF8);
}
```

### Step 4: Register in Main Generator

In `ValueObjectIncrementalGenerator.cs`:

```csharp
public void Initialize(IncrementalGeneratorInitializationContext ctx)
{
    var vosProvider = VoDeclarationProvider.Setup(ctx).Collect();

    ctx.RegisterSourceOutput(
        ctx.CompilationProvider.Combine(vosProvider),
        (spc, source) =>
        {
            var (compilation, voArray) = source;
            
            // ... existing emitters ...
            
            // Add your emitter here
            MyFeatureEmitter.Emit(spc, voArray);
        });
}
```

## Accessing VoCandidate Information

The `VoCandidate` record contains:

```csharp
string TypeName        // "UserId"
string? Namespace      // "MyApp.Domain" or null
string TvDisplay       // "global::System.Guid"
bool IsRecordStruct    // true if 'record struct'
bool IsReadOnly        // true if 'readonly'
```

### Example: Using VoCandidate Data

```csharp
var ro = vo.IsReadOnly ? "readonly " : string.Empty;
var rs = vo.IsRecordStruct ? "record struct" : "record";

sb.AppendLine($"public {ro} partial {rs} {vo.TypeName}");
```

## Type Analysis

To generate type-specific code, analyze the underlying type:

```csharp
private static void HandleType(StringBuilder sb, string tvDisplay)
{
    if (tvDisplay is "string" or "System.String")
    {
        // Handle string type
    }
    else if (IsNumericType(tvDisplay))
    {
        // Handle numeric types
    }
    else if (tvDisplay is "System.Guid" or "Guid")
    {
        // Handle Guid type
    }
    else
    {
        // Handle custom types
    }
}

private static bool IsNumericType(string typeDisplay)
{
    var cleanType = typeDisplay.Replace("global::", "").Replace("System.", "");
    return cleanType switch
    {
        "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" 
        or "long" or "ulong" or "float" or "double" or "decimal" => true,
        _ => false
    };
}
```

## Grouping by Underlying Type

Some features need to group value objects by their underlying type:

```csharp
public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
{
    // Group by underlying type
    var byType = vos
        .GroupBy(v => v.TvDisplay)
        .OrderBy(g => g.Key, StringComparer.Ordinal);

    foreach (var group in byType)
    {
        var underlyingType = group.Key;
        var voInThisGroup = group.ToList();
        
        // Generate one feature per underlying type
        GenerateForType(ctx, underlyingType, voInThisGroup);
    }
}
```

Example: See `TvAsEmitter.cs` which generates one `StringAs`, `GuidAs`, etc. per underlying type.

## Conditional Generation

To make an emitter conditional based on assembly settings:

```csharp
// In ValueObjectIncrementalGenerator.cs
var (genMongo, genEfCore) = GetSettings(compilation);

if (genMongo)
{
    MongoDbSerializerEmitter.Emit(spc, voArray);
}
```

For your emitter:

```csharp
// In ValueObjectIncrementalGenerator.cs, add similar logic:
if (someCondition)
{
    MyConditionalEmitter.Emit(spc, voArray);
}
```

## Best Practices

### 1. Always Add Auto-Generated Header

```csharp
sb.AppendLine("// <auto-generated />");
sb.AppendLine("#nullable enable");
```

### 2. Match Original Declaration Shape

```csharp
var ro = vo.IsReadOnly ? "readonly " : string.Empty;
var rs = vo.IsRecordStruct ? "record struct" : "record";
sb.AppendLine($"public {ro} partial {rs} {vo.TypeName}");
```

### 3. Use Unique File Names

```csharp
ctx.AddSource($"{vo.TypeName}_Feature.g.cs", ...);  // Good
ctx.AddSource("generated.cs", ...);                  // Bad - may conflict
```

### 4. Handle Null Namespaces

```csharp
if (vo.Namespace is not null)
{
    sb.AppendLine($"namespace {vo.Namespace};");
}
```

### 5. Use StringBuilder Efficiently

```csharp
// ✅ Good - build once, output once
var sb = new StringBuilder();
// ... append many lines ...
ctx.AddSource(filename, SourceText.From(sb.ToString(), Encoding.UTF8));

// ❌ Avoid - multiple allocations
ctx.AddSource(filename, "code" + "more" + "code");
```

### 6. Avoid Special Characters in Type Names

```csharp
// Use only alphanumeric and underscore in generated identifiers
var safeTypeName = vo.TypeName.Replace("`", "");
```

## Real Example: Simple Emitter

Here's a complete example that generates a simple helper method:

```csharp
// File: src/ValueObject.SourceGenerator/Emitters/ToStringHelperEmitter.cs

namespace ValueObject.SourceGenerator.Emitters;

internal static class ToStringHelperEmitter
{
    public static void Emit(SourceProductionContext ctx, IEnumerable<VoCandidate> vos)
    {
        foreach (var vo in vos)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            
            if (vo.Namespace is not null)
            {
                sb.AppendLine($"namespace {vo.Namespace};");
                sb.AppendLine();
            }

            var ro = vo.IsReadOnly ? "readonly " : string.Empty;
            var rs = vo.IsRecordStruct ? "record struct" : "record";
            sb.AppendLine($"public {ro} partial {rs} {vo.TypeName}");
            sb.AppendLine("{");
            sb.AppendLine($"    public string ToDisplayString() => Value.ToString() ?? \"<empty>\";");
            sb.AppendLine("}");

            ctx.AddSource($"{vo.TypeName}_ToStringHelper.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}
```

And register it:

```csharp
// In ValueObjectIncrementalGenerator.cs
ToStringHelperEmitter.Emit(spc, voArray);
```

## Testing Your Emitter

See [Testing Guide](./TESTING.md) for detailed testing instructions.

Quick test example:

```csharp
[Fact]
public void Emitter_Generates_Valid_CSharp()
{
    var source = @"
        using ValueObject.Core;
        public partial record UserId(Guid Value) : IValueObject<Guid>;
    ";

    var compilation = CompileSource(source);
    var generatedCode = compilation.GeneratedCode; // pseudo-code

    Assert.Contains("public void MyMethod()", generatedCode);
}
```

## Common Issues and Solutions

### Issue: Generated Code Won't Compile

**Solution:** Check your StringBuilder output:
```csharp
// Before calling ctx.AddSource, verify:
var code = sb.ToString();
Assert.NotEmpty(code);
Assert.Contains("namespace", code);
```

### Issue: Code Duplicated for Each Build

**Solution:** Ensure you use unique filenames:
```csharp
// Good
ctx.AddSource($"{vo.TypeName}_Feature.g.cs", ...);

// Bad - causes duplicates
ctx.AddSource("Feature.g.cs", ...);
```

### Issue: Namespace Not Appearing in Generated Code

**Solution:** Check for null namespace:
```csharp
if (vo.Namespace is not null)
{
    sb.AppendLine($"namespace {vo.Namespace};");
}
// else: file is in global namespace
```

### Issue: Emitter Not Being Called

**Solution:** Make sure it's registered in `ValueObjectIncrementalGenerator.cs`:
```csharp
ctx.RegisterSourceOutput(..., (spc, source) =>
{
    // ... 
    MyEmitter.Emit(spc, voArray);  // Add this line
});
```

## Next Steps

- **[Testing Guide](./TESTING.md)** - How to test emitters
- **[Architecture Overview](./ARCHITECTURE.md)** - How emitters fit in the system
- **[Getting Started](../GETTING_STARTED.md)** - User-facing documentation

