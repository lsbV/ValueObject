# Operators Emitter

## Overview

The OperatorsEmitter automatically generates operator overloads for value objects, enabling natural and intuitive syntax for comparisons, type conversions, and equality checks.

## Generated Code Example

For a value object like:

```csharp
public partial record Age(int Value) : IValueObject<int>;
```

The generator creates:

```csharp
// <auto-generated />
namespace YourNamespace;

public partial record Age
{
    // Implicit conversion to underlying type
    public static implicit operator int(Age v) => v.Value;

    // Explicit conversion from underlying type
    public static explicit operator Age(int v) => new(v);

    // Equality operators
    public static bool operator ==(Age left, int right) => left.Value == right;
    public static bool operator !=(Age left, int right) => left.Value != right;
    public static bool operator ==(int left, Age right) => left == right.Value;
    public static bool operator !=(int left, Age right) => left != right.Value;

    // Comparison operators (for numeric types only)
    public static bool operator <(Age left, Age right) => left.Value < right.Value;
    public static bool operator <=(Age left, Age right) => left.Value <= right.Value;
    public static bool operator >(Age left, Age right) => left.Value > right.Value;
    public static bool operator >=(Age left, Age right) => left.Value >= right.Value;

    public static bool operator <(Age left, int right) => left.Value < right;
    public static bool operator <=(Age left, int right) => left.Value <= right;
    public static bool operator >(Age left, int right) => left.Value > right;
    public static bool operator >=(Age left, int right) => left.Value >= right;

    public static bool operator <(int left, Age right) => left < right.Value;
    public static bool operator <=(int left, Age right) => left <= right.Value;
    public static bool operator >(int left, Age right) => left > right.Value;
    public static bool operator >=(int left, Age right) => left >= right.Value;
}
```

## Type Conversions

### Implicit Conversion to Underlying Type

All value objects support implicit conversion to their underlying type:

```csharp
public partial record UserId(Guid Value) : IValueObject<Guid>;

UserId userId = new UserId(Guid.NewGuid());

// Implicit conversion - no cast needed
Guid id = userId;

// Works in method calls
Console.WriteLine(id);
var list = new List<Guid> { userId }; // Automatically converts
```

**Benefits:**
- Natural syntax when you need the underlying value
- Works seamlessly with LINQ and collections
- No explicit casting required

### Explicit Conversion from Underlying Type

All value objects support explicit conversion from their underlying type:

```csharp
Guid id = Guid.NewGuid();

// Explicit conversion - cast required
UserId userId = (UserId)id;

// In method calls
method(productId: (ProductId)Guid.Parse("..."));
```

**Benefits:**
- Prevents accidental conversions
- Makes intent clear in code
- Compiler enforces explicit conversion

## Equality Operators

### Basic Equality

```csharp
public partial record Email(string Value) : IValueObject<string>;

var email1 = new Email("john@example.com");
var email2 = new Email("john@example.com");
var email3 = new Email("jane@example.com");

// Value object to value object
if (email1 == email2) { /* true - same underlying value */ }
if (email1 != email3) { /* true - different values */ }

// Value object to underlying type
if (email1 == "john@example.com") { /* true */ }
if (email1 != "jane@example.com") { /* true */ }

// Underlying type to value object (reverse order)
if ("john@example.com" == email1) { /* true */ }
if ("jane@example.com" != email1) { /* true */ }
```

### With Records

Since ValueObject uses `record`, you also get:

```csharp
// Record equality (structural)
var email1 = new Email("test@example.com");
var email2 = new Email("test@example.com");

Assert.Equal(email1, email2); // Records are equal if values match
Assert.True(email1 == email2); // Operator also works

// Equality with default record behavior
var email = default(Email?);
if (email is not null)
{
    // null check works naturally
}
```

## Comparison Operators

Comparison operators are automatically generated for numeric and comparable types:

### Supported Types for Comparisons

- Integer types: `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`
- Floating-point: `float`, `double`, `decimal`

### Usage Examples

```csharp
public partial record Age(int Value) : IValueObject<int>;
public partial record Price(decimal Value) : IValueObject<decimal>;

// Between value objects
var age1 = new Age(25);
var age2 = new Age(30);

if (age1 < age2) { /* true */ }
if (age1 <= age2) { /* true */ }
if (age1 > age2) { /* false */ }
if (age1 >= age2) { /* false */ }

// Between value object and underlying type
var age = new Age(25);

if (age < 30) { /* true */ }
if (age >= 18) { /* true */ }
if (age > 20) { /* true */ }
if (age <= 25) { /* true */ }

// Between underlying type and value object (reverse order)
if (25 <= age) { /* true */ }
if (30 > age) { /* true */ }
if (18 < age) { /* false */ }
if (25 >= age) { /* true */ }
```

### Practical Examples

```csharp
public partial record Quantity(int Value) : IValueObject<int>;
public partial record MinimumOrder(int Value) : IValueObject<int>;
public partial record MaxQuantity(int Value) : IValueObject<int>;

// Validation logic
var minOrder = new MinimumOrder(5);
var maxQuantity = new MaxQuantity(100);
var userQuantity = new Quantity(10);

if (userQuantity < minOrder)
{
    throw new InvalidOperationException("Quantity below minimum order");
}

if (userQuantity > maxQuantity)
{
    throw new InvalidOperationException("Quantity exceeds maximum");
}

// Filtering
var quantities = new[] 
{ 
    new Quantity(1), 
    new Quantity(5), 
    new Quantity(10), 
    new Quantity(50) 
};

var validQuantities = quantities.Where(q => q >= minOrder && q <= maxQuantity);
```

## Method Signatures

### Implicit Operator

```csharp
public static implicit operator TValue(ValueObjectType v) => v.Value;
```

Automatically converts value object to underlying type without explicit cast.

### Explicit Operator

```csharp
public static explicit operator ValueObjectType(TValue v) => new(v);
```

Requires explicit cast to convert underlying type to value object.

### Equality Operators

```csharp
public static bool operator ==(ValueObjectType left, TValue right) => left.Value == right;
public static bool operator !=(ValueObjectType left, TValue right) => left.Value != right;
public static bool operator ==(TValue left, ValueObjectType right) => left == right.Value;
public static bool operator !=(TValue left, ValueObjectType right) => left != right.Value;
```

### Comparison Operators (Numeric Types Only)

```csharp
// Between value objects
public static bool operator <(ValueObjectType left, ValueObjectType right) => left.Value < right.Value;
public static bool operator <=(ValueObjectType left, ValueObjectType right) => left.Value <= right.Value;
public static bool operator >(ValueObjectType left, ValueObjectType right) => left.Value > right.Value;
public static bool operator >=(ValueObjectType left, ValueObjectType right) => left.Value >= right.Value;

// Between value object and underlying type
public static bool operator <(ValueObjectType left, TValue right) => left.Value < right;
public static bool operator <=(ValueObjectType left, TValue right) => left.Value <= right;
public static bool operator >(ValueObjectType left, TValue right) => left.Value > right;
public static bool operator >=(ValueObjectType left, TValue right) => left.Value >= right;

// Reverse order (underlying type on left)
public static bool operator <(TValue left, ValueObjectType right) => left < right.Value;
public static bool operator <=(TValue left, ValueObjectType right) => left <= right.Value;
public static bool operator >(TValue left, ValueObjectType right) => left > right.Value;
public static bool operator >=(TValue left, ValueObjectType right) => left >= right.Value;
```

## Real-World Examples

### Example 1: Shopping Cart with Prices

```csharp
public partial record Price(decimal Value) : IValueObject<decimal>;
public partial record Discount(decimal Value) : IValueObject<decimal>;

public class ShoppingCart
{
    public Price Total { get; private set; }

    public void ApplyDiscount(Discount discount)
    {
        // Using comparison operators
        if (discount > Total)
        {
            throw new InvalidOperationException("Discount exceeds total");
        }

        // Using implicit conversion for arithmetic
        Total = new Price((decimal)Total - (decimal)discount);
    }

    public void EnsureMinimumOrder(Price minimum)
    {
        // Natural comparison syntax
        if (Total < minimum)
        {
            throw new InvalidOperationException($"Order must be at least {minimum.Value:C}");
        }
    }
}
```

### Example 2: Age Verification

```csharp
public partial record Age(int Value) : IValueObject<int>;
public partial record MinimumAge(int Value) : IValueObject<int>;

public class UserService
{
    private readonly MinimumAge _minimumAge = new(18);

    public bool CanCreateAccount(Age userAge)
    {
        // Clear, readable comparison
        return userAge >= _minimumAge;
    }

    public IEnumerable<User> GetAdultUsers(IEnumerable<User> users)
    {
        // Works with LINQ
        return users.Where(u => u.Age >= _minimumAge);
    }

    public void DisplayAgeGroup(Age age)
    {
        // Multiple comparisons
        if (age >= 65)
            Console.WriteLine("Senior");
        else if (age >= 18)
            Console.WriteLine("Adult");
        else
            Console.WriteLine("Minor");
    }
}
```

### Example 3: Timeout Management

```csharp
public partial record Milliseconds(int Value) : IValueObject<int>;
public partial record TimeoutLimit(int Value) : IValueObject<int>;

public class RequestHandler
{
    public async Task<T> ExecuteWithTimeout<T>(
        Func<CancellationToken, Task<T>> operation,
        Milliseconds timeout)
    {
        var limit = new TimeoutLimit(30000); // 30 seconds

        // Validation using operators
        if (timeout > limit)
        {
            throw new ArgumentException(
                $"Timeout {timeout.Value}ms exceeds limit {limit.Value}ms");
        }

        using var cts = new CancellationTokenSource(timeout.Value);
        return await operation(cts.Token);
    }
}
```

## Performance Considerations

- **Inlining**: Generated operators are inline-friendly and often compiled to direct field access
- **Zero overhead**: Implicit conversion compiles to field access with no runtime cost
- **Stack allocation**: Works great with `record struct` for stack-allocated value objects
- **No boxing**: Operators avoid boxing for value types

## Common Patterns

### Pattern: Normalize to Value Object

```csharp
// Accept underlying type, convert to value object
public void ProcessId(Guid rawId)
{
    var userId = (UserId)rawId; // Explicit conversion
    DoSomething(userId);
}

// Or with implicit conversion in reverse
public void ProcessId(UserId userId)
{
    Guid rawId = userId; // Implicit conversion
    _repository.Delete(rawId);
}
```

### Pattern: Operate on Underlying Values

```csharp
var quantity1 = new Quantity(5);
var quantity2 = new Quantity(3);

// Convert to underlying type for arithmetic
var total = (int)quantity1 + (int)quantity2; // 8

// Or create new value object
var combined = new Quantity((int)quantity1 + (int)quantity2);
```

### Pattern: Conditional Logic

```csharp
if (priority >= new Priority(5))
{
    // High priority - process immediately
}
else if (priority >= new Priority(3))
{
    // Medium priority - queue
}
else
{
    // Low priority - defer
}
```

## Next Steps

- **[Getting Started](./GETTING_STARTED.md)** - Basic usage guide
- **[Type Extensions](./TYPE_EXTENSIONS.md)** - The `As` pattern for conversions
- **[TryParse Emitter](./TRYPARSE_EMITTER.md)** - Safe parsing methods
- **[Configuration](./CONFIGURATION.md)** - Customize generator behavior

