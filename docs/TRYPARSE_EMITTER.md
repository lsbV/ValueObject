# TryParse Emitter

## Overview

The TryParseEmitter is a source generator that automatically generates `TryParse` methods for value objects, enabling safe parsing from strings and seamless integration with ASP.NET Core minimal APIs, CLI applications, and query string parsers.

## Why TryParse?

The `TryParse` pattern provides:
- **Safety**: Returns `bool` instead of throwing exceptions
- **Compatibility**: Works with ASP.NET Core's model binding system
- **Consistency**: Standard .NET pattern that developers expect
- **Flexibility**: Supports format providers for localization

## Generated Code Example

### String-Based Value Object

For a value object like:

```csharp
public partial record Email(string Value) : IValueObject<string>;
```

The generator creates:

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

public partial record Email
{
    public static bool TryParse(string? value, IFormatProvider? provider, out Email result)
    {
        result = default!; // assign default to out parameter
        if (string.IsNullOrEmpty(value))
            return false;

        result = new(value!);
        return true;
    }

    public static bool TryParse(string? value, out Email result)
    {
        return TryParse(value, null, out result);
    }
}
```

### Numeric Value Object

For:

```csharp
public partial record Age(int Value) : IValueObject<int>;
```

The generator creates:

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

public partial record Age
{
    public static bool TryParse(string? value, IFormatProvider? provider, out Age result)
    {
        result = default!;
        if (string.IsNullOrEmpty(value))
            return false;

        // Try TryParse(string, NumberStyles, IFormatProvider, out T)
        if (int.TryParse(value, System.Globalization.NumberStyles.Any, provider, out var parsedValue))
        {
            result = new(parsedValue);
            return true;
        }

        return false;
    }

    public static bool TryParse(string? value, out Age result)
    {
        return TryParse(value, null, out result);
    }
}
```

### GUID Value Object

For:

```csharp
public partial record UserId(Guid Value) : IValueObject<Guid>;
```

The generator creates:

```csharp
#nullable enable
// <auto-generated />
namespace YourNamespace;

public partial record UserId
{
    public static bool TryParse(string? value, IFormatProvider? provider, out UserId result)
    {
        result = default!;
        if (string.IsNullOrEmpty(value))
            return false;

        // Try TryParse(string, IFormatProvider, out T)
        if (Guid.TryParse(value, provider, out var parsedValue))
        {
            result = new(parsedValue);
            return true;
        }

        return false;
    }

    public static bool TryParse(string? value, out UserId result)
    {
        return TryParse(value, null, out result);
    }
}
```

## Usage Examples

### Basic Parsing

```csharp
// Parse a string value object
if (Email.TryParse("john@example.com", out var email))
{
    Console.WriteLine($"Email: {email.Value}"); // Output: Email: john@example.com
}
else
{
    Console.WriteLine("Invalid email");
}

// Parse with format provider for culture-specific formats
var culture = CultureInfo.GetCultureInfo("de-DE");
if (Price.TryParse("19,99", culture, out var price))
{
    Console.WriteLine($"Price: {price.Value}"); // Output: Price: 19.99
}
```

### ASP.NET Core Minimal APIs

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Value objects are automatically parsed from route parameters
app.MapGet("/users/{userId}", (UserId userId) => 
{
    // userId is automatically parsed from the route via generated TryParse
    return Results.Ok($"User: {userId.Value}");
});

app.MapPost("/products/{productId}/quantity/{quantity}", 
    (ProductId productId, Quantity quantity) =>
    {
        // Both productId and quantity are automatically parsed and type-safe
        return Results.Ok(new 
        { 
            ProductId = productId.Value, 
            Quantity = quantity.Value 
        });
    });

// Works with query strings too
app.MapGet("/search", (string? query, PageSize pageSize, SortBy sort) =>
{
    return Results.Ok(new { query, pageSize.Value, sort.Value });
});

app.Run();
```

### Command-Line Parsing

```csharp
// Build a simple CLI application
Console.WriteLine("Enter your age:");
string? input = Console.ReadLine();

if (Age.TryParse(input, out var age))
{
    Console.WriteLine($"You are {age.Value} years old");
}
else
{
    Console.WriteLine("Invalid age");
}
```

### Parsing from Configuration

```csharp
var builder = WebApplication.CreateBuilder(args);
var config = builder.Configuration;

// Parse value objects from configuration
if (Port.TryParse(config["ServerPort"], out var port))
{
    builder.WebHost.UseUrls($"http://localhost:{port.Value}");
}

if (Timeout.TryParse(config["RequestTimeout"], out var timeout))
{
    // Use timeout
}
```

### User Input Handling

```csharp
public async Task<IActionResult> CreateOrder(string? productIdInput, string? quantityInput)
{
    if (!ProductId.TryParse(productIdInput, out var productId))
    {
        ModelState.AddModelError(nameof(productId), "Invalid product ID format");
    }

    if (!Quantity.TryParse(quantityInput, out var quantity))
    {
        ModelState.AddModelError(nameof(quantity), "Invalid quantity format");
    }

    if (!ModelState.IsValid)
        return View();

    // Both productId and quantity are now safely parsed
    await _orderService.CreateAsync(productId, quantity);
    return RedirectToAction(nameof(Confirmation));
}
```

## Supported Types

The emitter automatically handles parsing for these underlying types:

### Primitive Numeric Types
- `byte`, `sbyte`
- `short`, `ushort`
- `int`, `uint`
- `long`, `ulong`
- `float`, `double`
- `decimal`

**Parsing behavior**: Uses `TryParse(string, NumberStyles.Any, IFormatProvider, out T)` for flexible parsing that handles different number formats and decimal separators based on the format provider.

### Boolean
- `bool`

**Parsing behavior**: Standard `bool.TryParse(string, out bool)`

### String
- `string`

**Parsing behavior**: Directly wraps non-empty strings. Returns `false` for `null` or empty strings.

### Guid
- `System.Guid` / `Guid`

**Parsing behavior**: Uses `Guid.TryParse(string, IFormatProvider, out Guid)`. Supports all standard Guid formats.

### Date/Time Types
- `System.DateTime` / `DateTime`
- `System.DateOnly` / `DateOnly`
- `System.TimeOnly` / `TimeOnly`

**Parsing behavior**: Uses the type's `TryParse` method with format provider for culture-specific parsing.

### MongoDB Types
- `MongoDB.Bson.ObjectId`

**Parsing behavior**: Uses `ObjectId.Parse(string)` with exception handling. Returns `false` on invalid ObjectId format.

### Custom Types

Any custom type implementing the standard `TryParse` pattern is supported:

```csharp
public partial record PhoneNumber(CustomPhoneNumberType Value) : IValueObject<CustomPhoneNumberType>;
```

As long as `CustomPhoneNumberType` has:
- `static bool TryParse(string?, IFormatProvider?, out CustomPhoneNumberType)`

The generator will use it automatically.

## Type-Specific Behavior

### Numeric Types: Format Provider Support

```csharp
// German format uses comma for decimal separator
var germanCulture = CultureInfo.GetCultureInfo("de-DE");
if (Price.TryParse("123,45", germanCulture, out var price))
{
    // price.Value == 123.45m
}

// US format uses period
var usCulture = CultureInfo.GetCultureInfo("en-US");
if (Price.TryParse("123.45", usCulture, out var price))
{
    // price.Value == 123.45m
}
```

### Guid Formats

```csharp
// All these formats are accepted
UserId.TryParse("550e8400-e29b-41d4-a716-446655440000", out var id1); // Standard
UserId.TryParse("{550e8400-e29b-41d4-a716-446655440000}", out var id2); // With braces
UserId.TryParse("550e8400e29b41d4a716446655440000", out var id3); // No hyphens
```

### String Types: Whitespace Handling

```csharp
Email.TryParse("test@example.com", out var email); // ✓ Valid
Email.TryParse("   ", out var email); // ✓ Valid (whitespace is accepted)
Email.TryParse("", out var email); // ✗ Returns false
Email.TryParse(null, out var email); // ✗ Returns false
```

### ObjectId: Exception Handling

```csharp
// Valid ObjectId format
EntityId.TryParse("507f1f77bcf86cd799439011", out var id); // ✓ Success

// Invalid format (handled gracefully, no exception thrown)
EntityId.TryParse("invalid", out var id); // ✗ Returns false
EntityId.TryParse(null, out var id); // ✗ Returns false
```

## Method Signatures

Every value object gets two overloads:

### With Format Provider

```csharp
public static bool TryParse(string? value, IFormatProvider? provider, out T result)
```

**Parameters:**
- `value`: The string to parse (can be null or empty)
- `provider`: Culture-specific formatting information (can be null for invariant culture)
- `result`: The parsed value object (set to `default!` if parsing fails)

**Returns:** `true` if parsing succeeded, `false` otherwise

**Use when:** You need to support different number formats or cultures

### Without Format Provider (Convenience Overload)

```csharp
public static bool TryParse(string? value, out T result)
```

**Parameters:**
- `value`: The string to parse (can be null or empty)
- `result`: The parsed value object (set to `default!` if parsing fails)

**Returns:** `true` if parsing succeeded, `false` otherwise

**Use when:** You don't need format provider support or want simpler code

## Error Handling

All parsing operations are safe and never throw exceptions:

```csharp
// No exceptions, just returns false
Age.TryParse("not-a-number", out var age); // false
Age.TryParse(null, out var age); // false
Age.TryParse("", out var age); // false

// Handle the result gracefully
if (Age.TryParse(userInput, out var parsedAge))
{
    // Use parsedAge
}
else
{
    // Show error message to user
    Console.WriteLine($"'{userInput}' is not a valid age");
}
```

## Performance Notes

- **Zero-cost**: Generated methods are inline-friendly and produce efficient IL
- **No reflection**: Parsing is done through direct `TryParse` calls on the underlying type
- **Struct support**: Works efficiently with `record struct` value objects
- **Allocation-free**: For reference types, allocates only the new value object (not additional intermediate objects)

## Next Steps

- **[Getting Started](./GETTING_STARTED.md)** - Basic usage guide
- **[Operators Emitter](./OPERATORS_EMITTER.md)** - Operator overloading
- **[Type Extensions](./TYPE_EXTENSIONS.md)** - The `As` pattern
- **[Configuration](./CONFIGURATION.md)** - Customize generator behavior

